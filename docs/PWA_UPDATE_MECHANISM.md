# Как работает обновление PWA приложения

## Текущая реализация

### 1. Регистрация Service Worker

При загрузке приложения (`src/main.tsx`) автоматически регистрируется Service Worker из файла `/sw.js`.

**Код регистрации** (`src/utils/registerServiceWorker.ts`):
- Service Worker регистрируется при каждом запуске приложения
- Проверка обновлений происходит **каждые 60 секунд** автоматически
- При обнаружении нового Service Worker показывается диалог подтверждения

### 2. Механизм обновления

#### Шаг 1: Обнаружение обновления
```
Браузер → Проверяет /sw.js каждые 60 секунд
         ↓
    Если файл изменился (по байтам или хешу)
         ↓
    Браузер обнаруживает новую версию
```

#### Шаг 2: Установка нового Service Worker
```
Новый Service Worker → Устанавливается в фоне
                     ↓
              Состояние: "installing"
                     ↓
              Состояние: "installed"
```

#### Шаг 3: Уведомление пользователя
```
Код в registerServiceWorker.ts → Слушает событие 'updatefound'
                                 ↓
                          Показывает confirm диалог:
                          "Доступна новая версия приложения. Обновить?"
```

#### Шаг 4: Активация обновления
```
Пользователь нажимает "OK"
         ↓
Отправляется сообщение: { type: 'SKIP_WAITING' }
         ↓
Service Worker активируется немедленно
         ↓
Страница перезагружается: window.location.reload()
```

### 3. Проблема с кэшем

**Текущая проблема**: В `sw.js` используется фиксированное имя кэша:
```javascript
const CACHE_NAME = 'equipment-app-v1';
```

**Что это означает:**
- При обновлении приложения старые файлы могут остаться в кэше
- Новые файлы (JS, CSS) могут не загрузиться, если они кэшированы
- Пользователь может видеть старую версию приложения

## Как происходит обновление на разных устройствах

### Сценарий 1: Устройство онлайн при обновлении

1. **Пользователь открывает приложение**
2. **Service Worker проверяет обновления** (каждые 60 секунд)
3. **Обнаружена новая версия** → Показывается диалог
4. **Пользователь подтверждает** → Приложение перезагружается
5. **Новый Service Worker активируется** → Загружаются новые файлы

### Сценарий 2: Устройство офлайн при обновлении

1. **Пользователь открывает приложение** (офлайн)
2. **Service Worker работает с кэшем** → Показывается старая версия
3. **При появлении интернета** → Service Worker проверяет обновления
4. **Обнаружена новая версия** → Показывается диалог при следующем открытии

### Сценарий 3: Устройство не открывалось долгое время

1. **Пользователь открывает приложение** (после долгого перерыва)
2. **Service Worker сразу проверяет обновления**
3. **Обнаружена новая версия** → Показывается диалог
4. **После обновления** → Загружается актуальная версия

## Проблемы текущей реализации

### ❌ Проблема 1: Фиксированное имя кэша

**Проблема**: `CACHE_NAME = 'equipment-app-v1'` не меняется при обновлении.

**Последствия**:
- Старые файлы могут остаться в кэше
- Новые версии JS/CSS могут не загрузиться
- Пользователь видит смешанную версию (старый HTML + новый JS)

### ❌ Проблема 2: Confirm диалог неудобен

**Проблема**: `window.confirm()` блокирует интерфейс и выглядит несовременно.

**Последствия**:
- Плохой UX
- Пользователь может закрыть диалог и не обновиться

### ❌ Проблема 3: Нет автоматического обновления кэша

**Проблема**: Кэш не обновляется автоматически при изменении файлов.

**Последствия**:
- Нужно вручную менять версию кэша
- Старые файлы могут использоваться долгое время

## Рекомендуемые улучшения

### 1. Динамическое имя кэша (с версией)

**Решение**: Использовать версию из package.json или дату сборки:

```javascript
// Вариант 1: Использовать версию из package.json (через build-time замену)
const CACHE_NAME = 'equipment-app-v1.0.0';

// Вариант 2: Использовать хеш сборки (Vite автоматически добавляет хеш к файлам)
const CACHE_NAME = `equipment-app-${BUILD_HASH}`;

// Вариант 3: Использовать дату сборки
const CACHE_NAME = `equipment-app-${BUILD_DATE}`;
```

### 2. Улучшенное уведомление об обновлении

**Решение**: Использовать Toast уведомление вместо confirm:

```typescript
// Вместо window.confirm использовать toast
toast.info('Доступна новая версия приложения', {
  action: {
    label: 'Обновить',
    onClick: () => {
      installingWorker.postMessage({ type: 'SKIP_WAITING' });
      window.location.reload();
    }
  }
});
```

### 3. Автоматическая очистка старых кэшей

**Решение**: Улучшить логику активации Service Worker:

```javascript
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          // Удаляем все кэши, которые не соответствуют текущей версии
          if (!cacheName.startsWith('equipment-app-')) {
            return caches.delete(cacheName);
          }
          // Или удаляем все старые версии
          if (cacheName !== CACHE_NAME) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});
```

### 4. Стратегия обновления кэша

**Решение**: Использовать "Network First" для HTML и "Cache First" для статики:

```javascript
// Для index.html - всегда проверяем сеть
if (event.request.url.endsWith('/index.html')) {
  event.respondWith(
    fetch(event.request)
      .then((response) => {
        // Обновляем кэш при каждом запросе
        caches.open(CACHE_NAME).then((cache) => {
          cache.put(event.request, response.clone());
        });
        return response;
      })
      .catch(() => caches.match(event.request))
  );
}
```

## Как проверить обновление вручную

### На устройстве:

1. **Откройте DevTools** (F12 или через меню браузера)
2. **Перейдите в Application → Service Workers**
3. **Нажмите "Update"** рядом с зарегистрированным Service Worker
4. **Или нажмите "Unregister"** и перезагрузите страницу

### Через код:

```javascript
// В консоли браузера
navigator.serviceWorker.getRegistrations().then(registrations => {
  registrations.forEach(registration => {
    registration.update();
  });
});
```

## Рекомендации для пользователей

### Если приложение не обновляется:

1. **Закройте приложение полностью** (не просто сверните)
2. **Откройте заново** → Service Worker проверит обновления
3. **Если не помогло**: Очистите кэш браузера для вашего сайта
4. **Или**: Переустановите PWA (удалите и установите заново)

### Для разработчиков:

1. **При каждом деплое** меняйте версию в `CACHE_NAME`
2. **Или** используйте автоматическую генерацию версии при сборке
3. **Тестируйте обновление** на разных устройствах

## Реализованные улучшения ✅

### 1. ✅ Автоматическая версия кэша при сборке

**Реализовано**: В `vite.config.ts` добавлен плагин `serviceWorkerCacheVersion`, который автоматически заменяет `__CACHE_VERSION__` на timestamp при каждой сборке.

**Как работает**:
- При выполнении `npm run build` плагин заменяет `__CACHE_VERSION__` на текущий timestamp
- Это гарантирует, что каждая сборка имеет уникальное имя кэша
- Старые кэши автоматически удаляются при активации нового Service Worker

**Файлы**:
- `vite.config.ts` - плагин для замены версии
- `public/sw.js` - использует `__CACHE_VERSION__` плейсхолдер

### 2. ✅ Toast уведомление вместо confirm

**Реализовано**: Заменен `window.confirm()` на современное Toast уведомление с кнопкой "Обновить".

**Как работает**:
- При обнаружении нового Service Worker показывается информационное Toast уведомление
- Уведомление содержит кнопку "Обновить" для немедленного обновления
- Уведомление не закрывается автоматически, чтобы пользователь мог обновить приложение
- Используется библиотека `react-toastify`, уже присутствующая в проекте

**Файлы**:
- `src/utils/registerServiceWorker.ts` - логика показа Toast уведомления
- `src/utils/toast.ts` - утилиты для работы с Toast

### 3. ✅ Улучшенная стратегия обновления кэша

**Реализовано**: Для `index.html` используется стратегия "Network First" - всегда проверяется сеть перед использованием кэша.

**Как работает**:
- При запросе `index.html` сначала проверяется сеть
- Если сеть доступна, загружается новая версия и обновляется кэш
- Если сеть недоступна, используется кэш
- Это гарантирует, что пользователи всегда получают актуальную версию HTML

**Файлы**:
- `public/sw.js` - логика обработки запросов

### 4. ✅ Автоматическая очистка старых кэшей

**Реализовано**: При активации нового Service Worker автоматически удаляются все старые кэши.

**Как работает**:
- При активации Service Worker проверяются все существующие кэши
- Удаляются все кэши, которые начинаются с `equipment-app-` но не соответствуют текущей версии
- Также удаляются любые другие несвязанные кэши

**Файлы**:
- `public/sw.js` - логика активации и очистки кэшей

---

## Текущее состояние

**✅ Все основные улучшения реализованы!**

Механизм обновления теперь работает полностью автоматически:
- ✅ Версия кэша обновляется автоматически при каждой сборке
- ✅ Пользователи получают современные Toast уведомления вместо блокирующих диалогов
- ✅ HTML всегда загружается из сети для актуальности
- ✅ Старые кэши автоматически очищаются

### Что происходит при обновлении:

1. **Разработчик**: Выполняет `npm run build` → версия кэша автоматически обновляется
2. **Деплой**: Новая версия загружается на сервер
3. **Пользователь**: Открывает приложение → Service Worker проверяет обновления каждые 60 секунд
4. **Обнаружение**: Браузер обнаруживает новый Service Worker
5. **Уведомление**: Показывается Toast с кнопкой "Обновить"
6. **Обновление**: Пользователь нажимает "Обновить" → приложение перезагружается с новой версией
7. **Очистка**: Старые кэши автоматически удаляются

### Дополнительные возможности (опционально):

- Добавить индикатор обновления в UI (например, в шапке приложения)
- Добавить возможность принудительного обновления через меню настроек
- Добавить версию приложения в UI для отладки
